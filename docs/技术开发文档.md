# 五子棋微信小游戏 - 技术开发文档

## 一、技术架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    微信小游戏客户端                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │ 游戏界面  │  │ WebSocket │  │ 微信API   │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────┬───────────────────────────────────┘
                      │ HTTPS/WSS
┌─────────────────────▼───────────────────────────────────┐
│                    Nginx (反向代理)                       │
└─────────────┬───────────────────┬───────────────────────┘
              │                   │
    ┌─────────▼────────┐  ┌──────▼──────┐
    │  NestJS Server   │  │  WebSocket  │
    │   (RESTful API)  │  │  Gateway    │
    └─────────┬────────┘  └──────┬──────┘
              │                   │
    ┌─────────▼──────────────────▼────────┐
    │           Redis (缓存/队列)           │
    │  • 匹配队列                           │
    │  • 房间状态                           │
    │  • 在线用户                           │
    └──────────────────────────────────────┘
              │
    ┌─────────▼──────────┐
    │    MySQL 数据库     │
    │  • 用户表           │
    │  • 对战记录表       │
    │  • 排行榜表         │
    └────────────────────┘
```

### 1.2 技术栈选型

#### 前端（微信小游戏）
- **开发语言：** JavaScript / TypeScript
- **渲染引擎：** Canvas 2D API
- **框架选择方案：**
  - **方案一（推荐）：** 原生微信小游戏 + Canvas
    - 优点：轻量、启动快、包体积小
    - 适合：简单游戏逻辑
  - **方案二：** Cocos Creator
    - 优点：功能强大、组件丰富、开发效率高
    - 适合：复杂游戏逻辑、后续扩展
- **网络通信：** 
  - WebSocket (实时对战)
  - HTTPS (用户数据、排行榜)
- **状态管理：** 自定义 GameState 管理器

#### 后端
- **开发语言：** Node.js (v18+) + TypeScript
- **Web框架：** NestJS 10.x
- **实时通信：** @nestjs/websockets + Socket.io 4.x
- **ORM：** TypeORM (MySQL)
- **缓存：** Redis 7.x
  - @nestjs/redis + ioredis
- **认证：** @nestjs/jwt (JSON Web Token)
- **配置管理：** @nestjs/config
- **验证：** class-validator + class-transformer
- **日志：** @nestjs/common Logger
- **进程管理：** PM2

#### 数据库
- **关系型数据库：** MySQL 8.0
  - 用户数据
  - 对战记录
  - 排行榜
- **缓存数据库：** Redis 7.x
  - 在线用户列表
  - 匹配队列
  - 房间状态
  - 排行榜缓存

#### 运维部署
- **服务器：** 云服务器（已有）
- **操作系统：** Ubuntu 22.04 LTS
- **Web服务器：** Nginx 1.24
- **HTTPS证书：** Let's Encrypt
- **监控：** PM2 监控 + 自定义监控
- **备份：** MySQL定时备份

---

## 二、数据库设计

### 2.1 MySQL数据表设计

#### 2.1.1 用户表 (users)

```sql
CREATE TABLE `users` (
  `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
  `openid` VARCHAR(128) NOT NULL UNIQUE COMMENT '微信openid',
  `unionid` VARCHAR(128) DEFAULT NULL COMMENT '微信unionid',
  `nickname` VARCHAR(100) NOT NULL COMMENT '昵称',
  `avatar_url` VARCHAR(500) DEFAULT NULL COMMENT '头像URL',
  `level` INT DEFAULT 1 COMMENT '等级',
  `exp` INT DEFAULT 0 COMMENT '经验值',
  `total_games` INT DEFAULT 0 COMMENT '总对局数',
  `win_games` INT DEFAULT 0 COMMENT '胜利局数',
  `lose_games` INT DEFAULT 0 COMMENT '失败局数',
  `draw_games` INT DEFAULT 0 COMMENT '平局数',
  `win_streak` INT DEFAULT 0 COMMENT '当前连胜',
  `max_win_streak` INT DEFAULT 0 COMMENT '最高连胜',
  `rating` INT DEFAULT 1000 COMMENT 'ELO评分',
  `last_login_at` DATETIME DEFAULT NULL COMMENT '最后登录时间',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  INDEX `idx_rating` (`rating` DESC),
  INDEX `idx_win_games` (`win_games` DESC),
  INDEX `idx_max_win_streak` (`max_win_streak` DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

#### 2.1.2 对战记录表 (game_records)

```sql
CREATE TABLE `game_records` (
  `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '记录ID',
  `room_id` VARCHAR(64) NOT NULL COMMENT '房间ID',
  `game_type` TINYINT NOT NULL COMMENT '游戏类型 1随机匹配 2人机 3好友',
  `black_player_id` BIGINT UNSIGNED COMMENT '黑方玩家ID',
  `white_player_id` BIGINT UNSIGNED COMMENT '白方玩家ID',
  `winner_id` BIGINT UNSIGNED DEFAULT NULL COMMENT '胜者ID, NULL表示平局',
  `game_result` TINYINT NOT NULL COMMENT '结果 1黑胜 2白胜 3平局 4黑方超时 5白方超时',
  `total_steps` INT DEFAULT 0 COMMENT '总步数',
  `duration` INT DEFAULT 0 COMMENT '对局时长(秒)',
  `game_data` TEXT COMMENT '棋谱数据(JSON)',
  `ai_difficulty` TINYINT DEFAULT NULL COMMENT 'AI难度 1简单 2中等 3困难',
  `started_at` DATETIME NOT NULL COMMENT '开始时间',
  `ended_at` DATETIME NOT NULL COMMENT '结束时间',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  INDEX `idx_black_player` (`black_player_id`),
  INDEX `idx_white_player` (`white_player_id`),
  INDEX `idx_room_id` (`room_id`),
  INDEX `idx_started_at` (`started_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='对战记录表';
```

#### 2.1.3 排行榜表 (leaderboards)

```sql
CREATE TABLE `leaderboards` (
  `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT 'ID',
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `rank_type` VARCHAR(20) NOT NULL COMMENT '榜单类型 win/winrate/streak',
  `period` VARCHAR(20) NOT NULL COMMENT '周期 daily/weekly/monthly/all',
  `rank` INT NOT NULL COMMENT '排名',
  `score` DECIMAL(10,2) NOT NULL COMMENT '分数',
  `period_date` DATE NOT NULL COMMENT '周期日期',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  UNIQUE KEY `idx_unique_rank` (`rank_type`, `period`, `period_date`, `user_id`),
  INDEX `idx_rank` (`rank_type`, `period`, `period_date`, `rank`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='排行榜表';
```

#### 2.1.4 房间表 (rooms)

```sql
CREATE TABLE `rooms` (
  `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '房间ID',
  `room_code` VARCHAR(32) NOT NULL UNIQUE COMMENT '房间号',
  `creator_id` BIGINT UNSIGNED NOT NULL COMMENT '创建者ID',
  `room_type` TINYINT NOT NULL COMMENT '房间类型 1随机 3好友',
  `status` TINYINT DEFAULT 1 COMMENT '状态 1等待 2进行中 3已结束',
  `password` VARCHAR(64) DEFAULT NULL COMMENT '房间密码(加密)',
  `max_players` TINYINT DEFAULT 2 COMMENT '最大玩家数',
  `current_players` TINYINT DEFAULT 1 COMMENT '当前玩家数',
  `expires_at` DATETIME NOT NULL COMMENT '过期时间',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  INDEX `idx_room_code` (`room_code`),
  INDEX `idx_status` (`status`, `expires_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='房间表';
```

### 2.2 Redis数据结构设计

#### 2.2.1 在线用户
```
Key: online:users
Type: SET
Value: user_id
TTL: 无
描述: 存储当前在线用户ID集合
```

#### 2.2.2 匹配队列
```
Key: match:queue
Type: ZSET
Score: timestamp (匹配时间戳)
Value: user_id
描述: 按时间顺序存储等待匹配的用户
```

#### 2.2.3 房间信息
```
Key: room:{room_id}
Type: HASH
Fields:
  - id: 房间ID
  - creator_id: 创建者ID
  - black_player_id: 黑方玩家ID
  - white_player_id: 白方玩家ID
  - status: 房间状态
  - board: 棋盘状态(JSON字符串)
  - current_turn: 当前回合(black/white)
  - turn_start_time: 回合开始时间
TTL: 3600秒
```

#### 2.2.4 用户Socket映射
```
Key: user:socket:{user_id}
Type: STRING
Value: socket_id
TTL: 7200秒
描述: 用户ID到Socket ID的映射
```

#### 2.2.5 排行榜缓存
```
Key: leaderboard:{type}:{period}
Type: ZSET
Score: 分数
Value: user_id
TTL: 300秒
描述: 排行榜缓存，5分钟刷新
```

---

## 三、API接口设计

### 3.1 RESTful API

#### 3.1.1 用户相关

**1. 用户登录**
```
POST /api/auth/login
Request Body:
{
  "code": "微信登录code"
}

Response:
{
  "code": 0,
  "message": "success",
  "data": {
    "token": "jwt_token",
    "user": {
      "id": 1001,
      "nickname": "玩家昵称",
      "avatar_url": "头像URL",
      "level": 5,
      "total_games": 100,
      "win_games": 60,
      "win_rate": 0.60
    }
  }
}
```

**2. 获取用户信息**
```
GET /api/user/profile
Headers: Authorization: Bearer {token}

Response:
{
  "code": 0,
  "data": {
    "id": 1001,
    "nickname": "玩家昵称",
    "avatar_url": "头像URL",
    "level": 5,
    "exp": 2500,
    "total_games": 100,
    "win_games": 60,
    "lose_games": 35,
    "draw_games": 5,
    "win_rate": 0.60,
    "win_streak": 3,
    "max_win_streak": 8,
    "rating": 1250
  }
}
```

**3. 获取用户战绩**
```
GET /api/user/history?page=1&limit=20
Headers: Authorization: Bearer {token}

Response:
{
  "code": 0,
  "data": {
    "total": 100,
    "page": 1,
    "limit": 20,
    "records": [
      {
        "id": 5001,
        "game_type": 1,
        "opponent": {
          "id": 1002,
          "nickname": "对手昵称",
          "avatar_url": "对手头像"
        },
        "result": "win",
        "total_steps": 89,
        "duration": 420,
        "created_at": "2025-10-15 14:30:00"
      }
    ]
  }
}
```

#### 3.1.2 排行榜相关

**1. 获取排行榜**
```
GET /api/leaderboard?type=win&period=all&limit=100
Headers: Authorization: Bearer {token}

Parameters:
- type: win(胜场) | winrate(胜率) | streak(连胜)
- period: daily | weekly | monthly | all
- limit: 数量限制(默认100)

Response:
{
  "code": 0,
  "data": {
    "rank_list": [
      {
        "rank": 1,
        "user": {
          "id": 1001,
          "nickname": "五子棋大师",
          "avatar_url": "头像URL",
          "level": 15
        },
        "score": 500,
        "win_games": 500,
        "total_games": 600,
        "win_rate": 0.83
      }
    ],
    "my_rank": {
      "rank": 25,
      "score": 60
    }
  }
}
```

#### 3.1.3 房间相关

**1. 创建好友房间**
```
POST /api/room/create
Headers: Authorization: Bearer {token}
Request Body:
{
  "password": "123456" // 可选
}

Response:
{
  "code": 0,
  "data": {
    "room_id": "ABC123",
    "room_code": "ABC123",
    "creator_id": 1001,
    "expires_at": "2025-10-15 15:30:00"
  }
}
```

**2. 加入房间**
```
POST /api/room/join
Headers: Authorization: Bearer {token}
Request Body:
{
  "room_code": "ABC123",
  "password": "123456" // 可选
}

Response:
{
  "code": 0,
  "data": {
    "room_id": "ABC123",
    "creator": {
      "id": 1001,
      "nickname": "房主昵称",
      "avatar_url": "头像URL"
    },
    "status": "waiting"
  }
}
```

### 3.2 WebSocket事件设计

#### 3.2.1 连接事件

**客户端 -> 服务端**

**1. 连接认证**
```javascript
socket.emit('auth', {
  token: 'jwt_token'
})
```

**服务端 -> 客户端**
```javascript
socket.on('auth_success', (data) => {
  // data: { userId: 1001 }
})

socket.on('auth_failed', (error) => {
  // error: { message: '认证失败' }
})
```

#### 3.2.2 匹配相关

**客户端 -> 服务端**

**1. 开始匹配**
```javascript
socket.emit('start_match', {
  userId: 1001
})
```

**2. 取消匹配**
```javascript
socket.emit('cancel_match', {
  userId: 1001
})
```

**服务端 -> 客户端**

**1. 匹配成功**
```javascript
socket.on('match_success', (data) => {
  // data: {
  //   roomId: 'room_12345',
  //   opponent: {
  //     id: 1002,
  //     nickname: '对手',
  //     avatar_url: 'URL',
  //     level: 5,
  //     rating: 1200
  //   },
  //   color: 'black', // 你的颜色
  //   turnTime: 30 // 每步时间(秒)
  // }
})
```

**2. 匹配失败**
```javascript
socket.on('match_timeout', () => {
  // 匹配超时
})
```

#### 3.2.3 游戏对战

**客户端 -> 服务端**

**1. 落子**
```javascript
socket.emit('make_move', {
  roomId: 'room_12345',
  x: 7,
  y: 7
})
```

**2. 请求悔棋**
```javascript
socket.emit('request_undo', {
  roomId: 'room_12345'
})
```

**3. 响应悔棋请求**
```javascript
socket.emit('respond_undo', {
  roomId: 'room_12345',
  accept: true // true同意, false拒绝
})
```

**4. 认输**
```javascript
socket.emit('surrender', {
  roomId: 'room_12345'
})
```

**5. 请求和棋**
```javascript
socket.emit('request_draw', {
  roomId: 'room_12345'
})
```

**服务端 -> 客户端**

**1. 对手落子**
```javascript
socket.on('opponent_move', (data) => {
  // data: {
  //   x: 7,
  //   y: 7,
  //   color: 'black',
  //   step: 15
  // }
})
```

**2. 游戏结束**
```javascript
socket.on('game_over', (data) => {
  // data: {
  //   result: 'win', // win/lose/draw
  //   reason: 'five_in_row', // five_in_row/timeout/surrender
  //   winner: {
  //     id: 1001,
  //     nickname: '胜者'
  //   },
  //   totalSteps: 89,
  //   duration: 420,
  //   gameData: [...] // 完整棋谱
  // }
})
```

**3. 回合开始**
```javascript
socket.on('turn_start', (data) => {
  // data: {
  //   color: 'black', // 当前回合颜色
  //   remainTime: 30 // 剩余时间
  // }
})
```

**4. 超时警告**
```javascript
socket.on('timeout_warning', (data) => {
  // data: {
  //   remainTime: 10 // 剩余秒数
  // }
})
```

**5. 悔棋请求**
```javascript
socket.on('undo_request', () => {
  // 对方请求悔棋
})
```

**6. 悔棋结果**
```javascript
socket.on('undo_result', (data) => {
  // data: {
  //   accepted: true, // 是否同意
  //   board: [...] // 新的棋盘状态(如果同意)
  // }
})
```

---

## 四、核心算法设计

### 4.1 五子棋AI算法

#### 4.1.1 Minimax算法 + Alpha-Beta剪枝

```javascript
/**
 * AI评估函数
 * @param board 棋盘状态
 * @param color AI颜色
 * @returns 评估分数
 */
function evaluate(board, color) {
  let score = 0;
  
  // 评估所有方向的棋型
  // 五连: 100000
  // 活四: 10000
  // 冲四: 1000
  // 活三: 1000
  // 眠三: 100
  // 活二: 100
  // 眠二: 10
  
  return score;
}

/**
 * Minimax算法（带Alpha-Beta剪枝）
 * @param board 棋盘
 * @param depth 搜索深度
 * @param alpha Alpha值
 * @param beta Beta值
 * @param isMaximizing 是否最大化
 * @returns {score, move}
 */
function minimax(board, depth, alpha, beta, isMaximizing) {
  // 终止条件
  if (depth === 0 || isGameOver(board)) {
    return {
      score: evaluate(board, AI_COLOR),
      move: null
    };
  }
  
  const availableMoves = getAvailableMoves(board);
  let bestMove = null;
  
  if (isMaximizing) {
    let maxScore = -Infinity;
    
    for (const move of availableMoves) {
      makeMove(board, move, AI_COLOR);
      const result = minimax(board, depth - 1, alpha, beta, false);
      undoMove(board, move);
      
      if (result.score > maxScore) {
        maxScore = result.score;
        bestMove = move;
      }
      
      alpha = Math.max(alpha, maxScore);
      if (beta <= alpha) break; // Beta剪枝
    }
    
    return { score: maxScore, move: bestMove };
  } else {
    let minScore = Infinity;
    
    for (const move of availableMoves) {
      makeMove(board, move, PLAYER_COLOR);
      const result = minimax(board, depth - 1, alpha, beta, true);
      undoMove(board, move);
      
      if (result.score < minScore) {
        minScore = result.score;
        bestMove = move;
      }
      
      beta = Math.min(beta, minScore);
      if (beta <= alpha) break; // Alpha剪枝
    }
    
    return { score: minScore, move: bestMove };
  }
}

/**
 * 获取候选落子点（优化搜索空间）
 */
function getAvailableMoves(board) {
  const moves = [];
  const visited = new Set();
  
  // 只考虑已有棋子周围2格内的空位
  for (let i = 0; i < 15; i++) {
    for (let j = 0; j < 15; j++) {
      if (board[i][j] !== 0) {
        // 检查周围2格
        for (let dx = -2; dx <= 2; dx++) {
          for (let dy = -2; dy <= 2; dy++) {
            const x = i + dx;
            const y = j + dy;
            if (x >= 0 && x < 15 && y >= 0 && y < 15 && 
                board[x][y] === 0 && !visited.has(`${x},${y}`)) {
              moves.push({x, y});
              visited.add(`${x},${y}`);
            }
          }
        }
      }
    }
  }
  
  // 如果是第一步，返回中心点
  if (moves.length === 0) {
    return [{x: 7, y: 7}];
  }
  
  // 按威胁程度排序（提高剪枝效率）
  return moves.sort((a, b) => {
    return evaluatePosition(board, b) - evaluatePosition(board, a);
  });
}
```

#### 4.1.2 棋型识别

```javascript
/**
 * 棋型定义
 */
const PATTERNS = {
  FIVE: /11111/,           // 五连
  LIVE_FOUR: /011110/,     // 活四
  RUSH_FOUR: /11110|01111/, // 冲四
  LIVE_THREE: /011100|001110|010110/, // 活三
  // ... 更多棋型
};

/**
 * 检查胜利条件
 */
function checkWin(board, x, y, color) {
  const directions = [
    [[0, 1], [0, -1]],   // 水平
    [[1, 0], [-1, 0]],   // 垂直
    [[1, 1], [-1, -1]],  // 主对角线
    [[1, -1], [-1, 1]]   // 副对角线
  ];
  
  for (const [dir1, dir2] of directions) {
    let count = 1; // 包含当前棋子
    
    // 正向统计
    count += countDirection(board, x, y, dir1[0], dir1[1], color);
    // 反向统计
    count += countDirection(board, x, y, dir2[0], dir2[1], color);
    
    if (count >= 5) return true;
  }
  
  return false;
}

function countDirection(board, x, y, dx, dy, color) {
  let count = 0;
  let nx = x + dx;
  let ny = y + dy;
  
  while (nx >= 0 && nx < 15 && ny >= 0 && ny < 15 && 
         board[nx][ny] === color) {
    count++;
    nx += dx;
    ny += dy;
  }
  
  return count;
}
```

### 4.2 匹配算法

#### 4.2.1 ELO评分匹配

```javascript
/**
 * 匹配算法
 * 优先匹配rating相近的玩家
 */
async function findMatch(userId) {
  const user = await getUser(userId);
  const rating = user.rating;
  
  // 从Redis匹配队列中查找
  const queue = await redis.zrange('match:queue', 0, -1, 'WITHSCORES');
  
  for (let i = 0; i < queue.length; i += 2) {
    const opponentId = queue[i];
    const timestamp = parseInt(queue[i + 1]);
    
    if (opponentId === userId) continue;
    
    const opponent = await getUser(opponentId);
    const ratingDiff = Math.abs(rating - opponent.rating);
    const waitTime = Date.now() - timestamp;
    
    // 等待时间越长，匹配范围越宽松
    const maxDiff = 100 + waitTime / 1000 * 10;
    
    if (ratingDiff <= maxDiff) {
      // 匹配成功
      await redis.zrem('match:queue', userId);
      await redis.zrem('match:queue', opponentId);
      
      return {
        player1: user,
        player2: opponent
      };
    }
  }
  
  // 未找到匹配，加入队列
  await redis.zadd('match:queue', Date.now(), userId);
  return null;
}
```

### 4.3 排行榜更新算法

```javascript
/**
 * 更新排行榜（定时任务）
 */
async function updateLeaderboard(rankType, period) {
  let query = 'SELECT id, nickname, avatar_url, ';
  
  switch(rankType) {
    case 'win':
      query += 'win_games as score FROM users WHERE win_games > 0 ';
      break;
    case 'winrate':
      query += '(win_games * 100.0 / total_games) as score FROM users WHERE total_games >= 10 ';
      break;
    case 'streak':
      query += 'max_win_streak as score FROM users WHERE max_win_streak > 0 ';
      break;
  }
  
  query += 'ORDER BY score DESC LIMIT 100';
  
  const users = await mysql.query(query);
  
  // 更新Redis缓存
  const key = `leaderboard:${rankType}:${period}`;
  await redis.del(key);
  
  for (const user of users) {
    await redis.zadd(key, user.score, user.id);
  }
  
  await redis.expire(key, 300); // 5分钟过期
  
  // 更新MySQL排行榜表
  const date = new Date().toISOString().split('T')[0];
  for (let i = 0; i < users.length; i++) {
    await Leaderboard.upsert({
      user_id: users[i].id,
      rank_type: rankType,
      period: period,
      rank: i + 1,
      score: users[i].score,
      period_date: date
    });
  }
}
```

---

## 五、项目结构

### 5.1 后端项目结构

```
gomoku-server/
├── src/
│   ├── modules/             # 功能模块（NestJS模块化）
│   │   ├── auth/            # 认证模块
│   │   │   ├── auth.module.ts
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── strategies/
│   │   │   │   └── jwt.strategy.ts
│   │   │   └── guards/
│   │   │       └── jwt-auth.guard.ts
│   │   ├── user/            # 用户模块
│   │   │   ├── user.module.ts
│   │   │   ├── user.controller.ts
│   │   │   ├── user.service.ts
│   │   │   └── entities/
│   │   │       └── user.entity.ts
│   │   ├── game/            # 游戏模块
│   │   │   ├── game.module.ts
│   │   │   ├── game.gateway.ts      # WebSocket Gateway
│   │   │   ├── game.service.ts
│   │   │   ├── game.controller.ts
│   │   │   └── entities/
│   │   │       └── game-record.entity.ts
│   │   ├── room/            # 房间模块
│   │   │   ├── room.module.ts
│   │   │   ├── room.controller.ts
│   │   │   ├── room.service.ts
│   │   │   └── entities/
│   │   │       └── room.entity.ts
│   │   ├── match/           # 匹配模块
│   │   │   ├── match.module.ts
│   │   │   ├── match.gateway.ts
│   │   │   └── match.service.ts
│   │   ├── leaderboard/     # 排行榜模块
│   │   │   ├── leaderboard.module.ts
│   │   │   ├── leaderboard.controller.ts
│   │   │   ├── leaderboard.service.ts
│   │   │   └── entities/
│   │   │       └── leaderboard.entity.ts
│   │   └── ai/              # AI模块
│   │       ├── ai.module.ts
│   │       ├── ai.service.ts
│   │       └── algorithms/
│   │           ├── minimax.ts
│   │           └── evaluator.ts
│   ├── common/              # 公共模块
│   │   ├── config/          # 配置
│   │   │   ├── database.config.ts
│   │   │   ├── redis.config.ts
│   │   │   └── wechat.config.ts
│   │   ├── constants/       # 常量定义
│   │   │   └── game.constants.ts
│   │   ├── decorators/      # 装饰器
│   │   │   └── user.decorator.ts
│   │   ├── filters/         # 异常过滤器
│   │   │   └── http-exception.filter.ts
│   │   ├── guards/          # 守卫
│   │   │   └── ws-jwt.guard.ts
│   │   ├── interceptors/    # 拦截器
│   │   │   └── transform.interceptor.ts
│   │   ├── pipes/           # 管道
│   │   │   └── validation.pipe.ts
│   │   └── dto/             # 数据传输对象
│   │       └── pagination.dto.ts
│   ├── shared/              # 共享模块
│   │   ├── redis/           # Redis模块
│   │   │   ├── redis.module.ts
│   │   │   └── redis.service.ts
│   │   └── wechat/          # 微信模块
│   │       ├── wechat.module.ts
│   │       └── wechat.service.ts
│   ├── tasks/               # 定时任务
│   │   └── leaderboard.task.ts
│   ├── utils/               # 工具函数
│   │   ├── logger.util.ts
│   │   └── response.util.ts
│   ├── app.module.ts        # 根模块
│   └── main.ts              # 应用入口
├── test/                    # 测试文件
├── .env.example             # 环境变量示例
├── nest-cli.json            # NestJS CLI配置
├── package.json
├── tsconfig.json
└── README.md
```

### 5.2 前端项目结构（微信小游戏）

```
gomoku-client/
├── js/
│   ├── base/                # 基础类
│   │   ├── Sprite.js        # 精灵基类
│   │   └── Pool.js          # 对象池
│   ├── runtime/             # 运行时
│   │   ├── GameInfo.js      # 游戏信息
│   │   └── Background.js    # 背景
│   ├── player/              # 玩家相关
│   │   ├── Board.js         # 棋盘
│   │   ├── Piece.js         # 棋子
│   │   └── Timer.js         # 计时器
│   ├── ui/                  # UI组件
│   │   ├── Button.js
│   │   ├── Dialog.js
│   │   └── Toast.js
│   ├── scenes/              # 场景
│   │   ├── HomeScene.js     # 首页
│   │   ├── GameScene.js     # 游戏场景
│   │   ├── RankScene.js     # 排行榜
│   │   └── ProfileScene.js  # 个人中心
│   ├── api/                 # API接口
│   │   ├── http.js          # HTTP请求封装
│   │   ├── socket.js        # WebSocket封装
│   │   └── wechat.js        # 微信API封装
│   ├── ai/                  # AI算法
│   │   ├── AI.js            # AI主类
│   │   └── evaluator.js     # 评估函数
│   ├── utils/               # 工具类
│   │   ├── DataBus.js       # 数据总线
│   │   └── AudioManager.js  # 音频管理
│   └── Main.js              # 游戏主类
├── images/                  # 图片资源
│   ├── board/               # 棋盘图片
│   ├── pieces/              # 棋子图片
│   └── ui/                  # UI图片
├── audios/                  # 音频资源
├── game.js                  # 游戏入口
└── game.json                # 游戏配置
```

---

## 六、开发计划

### 6.1 开发阶段划分

#### 第一阶段：基础架构搭建（1周）
**后端：**
- [ ] 项目初始化，技术栈搭建
- [ ] 数据库设计与创建
- [ ] Redis配置
- [ ] 基础框架搭建（Express + Socket.io）
- [ ] 用户认证系统（微信登录）
- [ ] 基础API接口

**前端：**
- [ ] 微信小游戏项目初始化
- [ ] 基础场景框架
- [ ] 棋盘绘制
- [ ] 棋子绘制
- [ ] 基础UI组件

#### 第二阶段：核心功能开发（2周）
**后端：**
- [ ] WebSocket实时通信
- [ ] 游戏房间管理
- [ ] 游戏逻辑（落子、胜负判断）
- [ ] 匹配系统
- [ ] AI算法实现

**前端：**
- [ ] 游戏逻辑实现
- [ ] 人机对战
- [ ] 随机匹配
- [ ] 好友对战
- [ ] 实时对战同步

#### 第三阶段：功能完善（1-2周）
- [ ] 排行榜系统
- [ ] 战绩系统
- [ ] 分享功能
- [ ] 音效和动画
- [ ] 断线重连
- [ ] 异常处理

#### 第四阶段：测试优化（1周）
- [ ] 功能测试
- [ ] 性能优化
- [ ] 安全加固
- [ ] Bug修复
- [ ] 压力测试

#### 第五阶段：上线部署（3-5天）
- [ ] 服务器部署
- [ ] Nginx配置
- [ ] HTTPS证书
- [ ] 微信小游戏提审
- [ ] 监控配置

### 6.2 人员配置建议
- **后端开发：** 1-2人
- **前端开发：** 1-2人
- **测试：** 1人
- **设计：** 1人（兼职）

### 6.3 开发工具
- **代码编辑器：** VS Code
- **版本控制：** Git + GitHub/GitLab
- **API测试：** Postman
- **数据库管理：** Navicat / MySQL Workbench
- **Redis管理：** RedisInsight
- **微信开发者工具：** 微信小游戏IDE

---

## 七、性能优化方案

### 7.1 前端优化
1. **资源优化**
   - 图片压缩（TinyPNG）
   - 使用纹理图集
   - 音频格式优化

2. **渲染优化**
   - Canvas局部刷新
   - 对象池复用
   - 避免频繁创建对象

3. **网络优化**
   - WebSocket心跳机制
   - 数据压缩
   - 请求合并

### 7.2 后端优化
1. **数据库优化**
   - 索引优化
   - 查询优化
   - 连接池配置
   - 读写分离（后期）

2. **缓存策略**
   - Redis缓存热点数据
   - 排行榜缓存
   - 用户信息缓存

3. **并发优化**
   - Node.js集群模式
   - PM2进程管理
   - 负载均衡（后期）

---

## 八、安全方案

### 8.1 认证安全
- JWT Token认证
- Token过期机制
- 防重放攻击

### 8.2 数据安全
- HTTPS加密传输
- 敏感数据加密存储
- SQL注入防护
- XSS防护

### 8.3 游戏安全
- 服务端验证所有落子
- 防作弊检测
- 异常行为监控
- 频率限制

---

## 九、监控与运维

### 9.1 监控指标
- **系统监控：** CPU、内存、磁盘
- **应用监控：** 在线人数、并发连接
- **业务监控：** DAU、对局数、匹配成功率
- **错误监控：** 异常日志、错误率

### 9.2 日志管理
- Winston日志框架
- 分级日志（error/warn/info/debug）
- 日志轮转
- 日志分析

### 9.3 备份策略
- MySQL每日自动备份
- 备份保留30天
- Redis AOF持久化

---

## 十、附录

### 10.1 环境变量配置示例

```bash
# .env
NODE_ENV=production
PORT=3000

# 数据库
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=gomoku

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# 微信
WECHAT_APP_ID=your_app_id
WECHAT_APP_SECRET=your_app_secret

# JWT
JWT_SECRET=your_jwt_secret
JWT_EXPIRES_IN=7d

# 其他
LOG_LEVEL=info
```

### 10.2 部署脚本示例

```bash
#!/bin/bash
# deploy.sh

echo "开始部署..."

# 拉取最新代码
git pull origin main

# 安装依赖
npm install --production

# 编译TypeScript
npm run build

# 数据库迁移
npm run migrate

# 重启服务
pm2 restart gomoku-server

echo "部署完成！"
```

### 10.3 参考资源
- [微信小游戏开发文档](https://developers.weixin.qq.com/minigame/dev/guide/)
- [Socket.io文档](https://socket.io/docs/)
- [Sequelize文档](https://sequelize.org/)
- [五子棋AI算法参考](https://github.com/lihongxun945/myblog/labels/五子棋AI)

---

**文档版本：** V1.0  
**创建日期：** 2025-10-15  
**创建人：** 技术团队  
**审核状态：** 待审核

