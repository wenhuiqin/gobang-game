# 五子棋微信小游戏 - 开发规范文档

> **重要提示：每位开发人员在开始编码前，必须完整阅读 `docs/` 文件夹下的所有文档，确保理解项目整体架构、产品需求和技术方案，避免开发思路偏离！**

---

## 一、文档阅读规范

### 1.1 必读文档清单

在开始任何开发工作前，必须按顺序阅读以下文档：

1. **产品需求文档.md** - 了解产品定位、功能需求、业务逻辑
2. **技术开发文档.md** - 了解技术架构、数据库设计、API设计
3. **开发规范文档.md**（本文档）- 遵循代码规范和开发流程

### 1.2 开发前自查清单

- [ ] 已阅读并理解产品需求文档
- [ ] 已阅读并理解技术开发文档
- [ ] 已阅读并理解开发规范文档
- [ ] 了解当前迭代的功能需求
- [ ] 了解相关模块的数据库设计
- [ ] 了解相关的API接口设计
- [ ] 清楚代码规范和命名规范

### 1.3 文档更新规范

- 任何架构变更、需求变更必须先更新相关文档
- 文档更新后需通知全体开发人员
- 每次迭代开始前，重新审阅docs文档

---

## 二、核心开发原则

### 2.1 禁止硬编码原则 ⚠️

**硬编码是指直接在代码中写入固定值，而不是通过配置、常量或数据库获取。**

#### ❌ 禁止的硬编码示例

```typescript
// ❌ 错误：硬编码魔法数字
if (user.level > 10) {
  // ...
}

// ❌ 错误：硬编码字符串
if (game.status === 'playing') {
  // ...
}

// ❌ 错误：硬编码URL
const apiUrl = 'https://api.example.com/game';

// ❌ 错误：硬编码时间
setTimeout(() => {}, 30000);

// ❌ 错误：硬编码配置
const ratingChange = score * 10;

// ❌ 错误：硬编码棋盘大小
for (let i = 0; i < 15; i++) {
  for (let j = 0; j < 15; j++) {
    // ...
  }
}
```

#### ✅ 正确的实现方式

```typescript
// ✅ 正确：使用常量
import { USER_LEVEL } from '@/common/constants/user.constants';
if (user.level > USER_LEVEL.INTERMEDIATE_THRESHOLD) {
  // ...
}

// ✅ 正确：使用枚举
enum GameStatus {
  WAITING = 'waiting',
  PLAYING = 'playing',
  FINISHED = 'finished'
}
if (game.status === GameStatus.PLAYING) {
  // ...
}

// ✅ 正确：使用环境变量
const apiUrl = this.configService.get('API_BASE_URL');

// ✅ 正确：使用配置常量
import { GAME_CONFIG } from '@/common/constants/game.constants';
setTimeout(() => {}, GAME_CONFIG.TURN_TIMEOUT);

// ✅ 正确：使用配置文件
const ratingChange = score * this.configService.get('RATING_MULTIPLIER');

// ✅ 正确：使用常量
import { BOARD_SIZE } from '@/common/constants/game.constants';
for (let i = 0; i < BOARD_SIZE; i++) {
  for (let j = 0; j < BOARD_SIZE; j++) {
    // ...
  }
}
```

### 2.2 配置管理规范

#### 2.2.1 环境变量配置（.env）

所有环境相关的配置必须使用环境变量：

```bash
# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=root
DB_PASSWORD=your_password
DB_DATABASE=gomoku

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# 微信配置
WECHAT_APP_ID=your_app_id
WECHAT_APP_SECRET=your_app_secret

# JWT配置
JWT_SECRET=your_jwt_secret
JWT_EXPIRES_IN=7d

# 服务配置
PORT=3000
NODE_ENV=development
```

#### 2.2.2 常量定义（constants）

所有业务相关的常量必须定义在 `src/common/constants/` 目录下：

**game.constants.ts - 游戏常量**
```typescript
/**
 * 游戏配置常量
 * 禁止在代码中直接使用数字，必须使用此处定义的常量
 */
export const GAME_CONFIG = {
  // 棋盘配置
  BOARD_SIZE: 15,                    // 棋盘大小 15x15
  WIN_COUNT: 5,                      // 胜利所需连子数
  
  // 时间配置（毫秒）
  TURN_TIMEOUT: 30 * 1000,           // 每步超时时间 30秒
  TURN_WARNING_TIME: 10 * 1000,      // 超时警告时间 10秒
  MATCH_TIMEOUT: 30 * 1000,          // 匹配超时时间 30秒
  ROOM_EXPIRE_TIME: 30 * 60 * 1000,  // 房间过期时间 30分钟
  
  // 匹配配置
  MATCH_RATING_DIFF_BASE: 100,       // 基础评分差
  MATCH_RATING_DIFF_INCREMENT: 10,   // 每秒增加的评分差
  
  // AI配置
  AI_DEPTH_EASY: 2,                  // 简单AI深度
  AI_DEPTH_MEDIUM: 4,                // 中等AI深度
  AI_DEPTH_HARD: 6,                  // 困难AI深度
  
  // 评分配置
  RATING_DEFAULT: 1000,              // 默认评分
  RATING_K_FACTOR: 32,               // ELO K因子
  
  // 经验配置
  EXP_PER_WIN: 50,                   // 胜利经验
  EXP_PER_LOSE: 20,                  // 失败经验
  EXP_PER_DRAW: 30,                  // 平局经验
} as const;

/**
 * 游戏类型枚举
 */
export enum GameType {
  RANDOM_MATCH = 1,  // 随机匹配
  AI_GAME = 2,       // 人机对战
  FRIEND_GAME = 3,   // 好友对战
}

/**
 * 游戏结果枚举
 */
export enum GameResult {
  BLACK_WIN = 1,      // 黑方胜
  WHITE_WIN = 2,      // 白方胜
  DRAW = 3,           // 平局
  BLACK_TIMEOUT = 4,  // 黑方超时
  WHITE_TIMEOUT = 5,  // 白方超时
}

/**
 * 棋子颜色枚举
 */
export enum PieceColor {
  EMPTY = 0,   // 空位
  BLACK = 1,   // 黑子
  WHITE = 2,   // 白子
}

/**
 * 房间状态枚举
 */
export enum RoomStatus {
  WAITING = 1,    // 等待中
  PLAYING = 2,    // 进行中
  FINISHED = 3,   // 已结束
}
```

**user.constants.ts - 用户常量**
```typescript
/**
 * 用户等级配置
 */
export const USER_LEVEL_CONFIG = [
  { level: 1, exp: 0, name: '新手' },
  { level: 2, exp: 100, name: '初学者' },
  { level: 3, exp: 300, name: '爱好者' },
  { level: 4, exp: 600, name: '熟练者' },
  { level: 5, exp: 1000, name: '高手' },
  { level: 6, exp: 1500, name: '专家' },
  { level: 7, exp: 2100, name: '大师' },
  { level: 8, exp: 2800, name: '宗师' },
  { level: 9, exp: 3600, name: '传奇' },
  { level: 10, exp: 4500, name: '至尊' },
] as const;

/**
 * 排行榜类型
 */
export enum RankType {
  WIN = 'win',           // 胜场榜
  WIN_RATE = 'winrate',  // 胜率榜
  STREAK = 'streak',     // 连胜榜
}

/**
 * 排行榜周期
 */
export enum RankPeriod {
  DAILY = 'daily',     // 日榜
  WEEKLY = 'weekly',   // 周榜
  MONTHLY = 'monthly', // 月榜
  ALL = 'all',         // 总榜
}

/**
 * 排行榜配置
 */
export const RANK_CONFIG = {
  MAX_RANK_SIZE: 100,           // 最大排行数量
  MIN_GAMES_FOR_WINRATE: 10,    // 胜率榜最少对局数
  CACHE_TTL: 300,                // 缓存时间（秒）
} as const;
```

**error-codes.constants.ts - 错误码常量**
```typescript
/**
 * 错误码定义
 * 格式：模块(2位) + 具体错误(3位)
 */
export const ERROR_CODES = {
  // 通用错误 (00xxx)
  SUCCESS: 0,
  UNKNOWN_ERROR: 500,
  PARAMS_ERROR: 400,
  
  // 认证错误 (10xxx)
  AUTH_TOKEN_INVALID: 10001,
  AUTH_TOKEN_EXPIRED: 10002,
  AUTH_WECHAT_LOGIN_FAILED: 10003,
  
  // 用户错误 (20xxx)
  USER_NOT_FOUND: 20001,
  USER_ALREADY_EXISTS: 20002,
  
  // 游戏错误 (30xxx)
  GAME_NOT_FOUND: 30001,
  GAME_ALREADY_STARTED: 30002,
  GAME_ALREADY_FINISHED: 30003,
  GAME_INVALID_MOVE: 30004,
  GAME_NOT_YOUR_TURN: 30005,
  GAME_POSITION_OCCUPIED: 30006,
  
  // 房间错误 (40xxx)
  ROOM_NOT_FOUND: 40001,
  ROOM_FULL: 40002,
  ROOM_PASSWORD_ERROR: 40003,
  ROOM_EXPIRED: 40004,
  
  // 匹配错误 (50xxx)
  MATCH_TIMEOUT: 50001,
  MATCH_ALREADY_IN_QUEUE: 50002,
} as const;

/**
 * 错误消息映射
 */
export const ERROR_MESSAGES: Record<number, string> = {
  [ERROR_CODES.SUCCESS]: '成功',
  [ERROR_CODES.UNKNOWN_ERROR]: '未知错误',
  [ERROR_CODES.PARAMS_ERROR]: '参数错误',
  
  [ERROR_CODES.AUTH_TOKEN_INVALID]: 'Token无效',
  [ERROR_CODES.AUTH_TOKEN_EXPIRED]: 'Token已过期',
  [ERROR_CODES.AUTH_WECHAT_LOGIN_FAILED]: '微信登录失败',
  
  [ERROR_CODES.USER_NOT_FOUND]: '用户不存在',
  [ERROR_CODES.USER_ALREADY_EXISTS]: '用户已存在',
  
  [ERROR_CODES.GAME_NOT_FOUND]: '游戏不存在',
  [ERROR_CODES.GAME_ALREADY_STARTED]: '游戏已开始',
  [ERROR_CODES.GAME_ALREADY_FINISHED]: '游戏已结束',
  [ERROR_CODES.GAME_INVALID_MOVE]: '无效的落子',
  [ERROR_CODES.GAME_NOT_YOUR_TURN]: '还没轮到你',
  [ERROR_CODES.GAME_POSITION_OCCUPIED]: '该位置已被占用',
  
  [ERROR_CODES.ROOM_NOT_FOUND]: '房间不存在',
  [ERROR_CODES.ROOM_FULL]: '房间已满',
  [ERROR_CODES.ROOM_PASSWORD_ERROR]: '房间密码错误',
  [ERROR_CODES.ROOM_EXPIRED]: '房间已过期',
  
  [ERROR_CODES.MATCH_TIMEOUT]: '匹配超时',
  [ERROR_CODES.MATCH_ALREADY_IN_QUEUE]: '已在匹配队列中',
};
```

### 2.3 使用配置的最佳实践

```typescript
// ✅ 在Service中使用配置
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GAME_CONFIG, GameStatus } from '@/common/constants/game.constants';

@Injectable()
export class GameService {
  constructor(private configService: ConfigService) {}
  
  async checkTimeout(gameId: string): Promise<boolean> {
    const game = await this.findGame(gameId);
    const now = Date.now();
    const turnStartTime = game.turnStartTime.getTime();
    
    // ✅ 使用常量而不是硬编码
    return (now - turnStartTime) > GAME_CONFIG.TURN_TIMEOUT;
  }
  
  async initializeBoard(): Promise<number[][]> {
    // ✅ 使用常量定义棋盘大小
    const board = Array(GAME_CONFIG.BOARD_SIZE)
      .fill(null)
      .map(() => Array(GAME_CONFIG.BOARD_SIZE).fill(0));
    
    return board;
  }
}
```

---

## 三、NestJS 开发规范

### 3.1 模块化开发

#### 3.1.1 模块结构

每个功能模块必须包含以下文件（按需）：

```
module-name/
├── module-name.module.ts      # 模块定义
├── module-name.controller.ts  # 控制器（HTTP）
├── module-name.gateway.ts     # 网关（WebSocket）
├── module-name.service.ts     # 服务（业务逻辑）
├── dto/                       # 数据传输对象
│   ├── create-xxx.dto.ts
│   ├── update-xxx.dto.ts
│   └── query-xxx.dto.ts
└── entities/                  # 实体类
    └── xxx.entity.ts
```

#### 3.1.2 模块示例

```typescript
// game.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { GameController } from './game.controller';
import { GameGateway } from './game.gateway';
import { GameService } from './game.service';
import { GameRecord } from './entities/game-record.entity';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([GameRecord]),
    UserModule, // 导入需要的其他模块
  ],
  controllers: [GameController],
  providers: [GameGateway, GameService],
  exports: [GameService], // 导出供其他模块使用
})
export class GameModule {}
```

### 3.2 依赖注入规范

```typescript
// ✅ 正确：使用构造函数注入
@Injectable()
export class GameService {
  constructor(
    @InjectRepository(GameRecord)
    private gameRecordRepository: Repository<GameRecord>,
    private userService: UserService,
    private redisService: RedisService,
    private configService: ConfigService,
  ) {}
}

// ❌ 错误：不要使用属性注入
@Injectable()
export class GameService {
  @Inject(UserService)
  private userService: UserService;  // 不推荐
}
```

### 3.3 Controller 开发规范

```typescript
import { Controller, Get, Post, Body, Param, Query, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '@/common/guards/jwt-auth.guard';
import { CurrentUser } from '@/common/decorators/user.decorator';
import { GameService } from './game.service';
import { CreateRoomDto } from './dto/create-room.dto';

@Controller('api/game')
@UseGuards(JwtAuthGuard) // 统一使用JWT守卫
export class GameController {
  constructor(private readonly gameService: GameService) {}
  
  /**
   * 创建房间
   * @param user 当前用户
   * @param dto 创建房间DTO
   */
  @Post('room/create')
  async createRoom(
    @CurrentUser() user: any,
    @Body() dto: CreateRoomDto,
  ) {
    return this.gameService.createRoom(user.id, dto);
  }
  
  /**
   * 获取游戏历史
   * @param user 当前用户
   * @param page 页码
   * @param limit 每页数量
   */
  @Get('history')
  async getHistory(
    @CurrentUser() user: any,
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 20,
  ) {
    return this.gameService.getHistory(user.id, page, limit);
  }
}
```

### 3.4 Service 开发规范

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { GameRecord } from './entities/game-record.entity';
import { GAME_CONFIG } from '@/common/constants/game.constants';
import { ERROR_CODES } from '@/common/constants/error-codes.constants';

@Injectable()
export class GameService {
  constructor(
    @InjectRepository(GameRecord)
    private gameRecordRepository: Repository<GameRecord>,
  ) {}
  
  /**
   * 查找游戏记录
   * @param gameId 游戏ID
   * @throws NotFoundException 游戏不存在
   */
  async findGameById(gameId: string): Promise<GameRecord> {
    const game = await this.gameRecordRepository.findOne({
      where: { id: gameId },
    });
    
    if (!game) {
      throw new NotFoundException({
        code: ERROR_CODES.GAME_NOT_FOUND,
        message: '游戏不存在',
      });
    }
    
    return game;
  }
  
  /**
   * 检查胜利条件
   * @param board 棋盘
   * @param x X坐标
   * @param y Y坐标
   * @param color 棋子颜色
   */
  checkWin(board: number[][], x: number, y: number, color: number): boolean {
    // ✅ 使用常量
    const directions = [
      [[0, 1], [0, -1]],   // 水平
      [[1, 0], [-1, 0]],   // 垂直
      [[1, 1], [-1, -1]],  // 主对角线
      [[1, -1], [-1, 1]],  // 副对角线
    ];
    
    for (const [dir1, dir2] of directions) {
      let count = 1;
      count += this.countDirection(board, x, y, dir1[0], dir1[1], color);
      count += this.countDirection(board, x, y, dir2[0], dir2[1], color);
      
      // ✅ 使用常量而不是硬编码数字5
      if (count >= GAME_CONFIG.WIN_COUNT) {
        return true;
      }
    }
    
    return false;
  }
  
  private countDirection(
    board: number[][],
    x: number,
    y: number,
    dx: number,
    dy: number,
    color: number,
  ): number {
    let count = 0;
    let nx = x + dx;
    let ny = y + dy;
    
    // ✅ 使用常量
    while (
      nx >= 0 && nx < GAME_CONFIG.BOARD_SIZE &&
      ny >= 0 && ny < GAME_CONFIG.BOARD_SIZE &&
      board[nx][ny] === color
    ) {
      count++;
      nx += dx;
      ny += dy;
    }
    
    return count;
  }
}
```

### 3.5 WebSocket Gateway 开发规范

```typescript
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  ConnectedSocket,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { UseGuards } from '@nestjs/common';
import { WsJwtGuard } from '@/common/guards/ws-jwt.guard';
import { GameService } from './game.service';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class GameGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;
  
  constructor(private readonly gameService: GameService) {}
  
  /**
   * 客户端连接
   */
  async handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`);
  }
  
  /**
   * 客户端断开
   */
  async handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
    await this.gameService.handleDisconnect(client.id);
  }
  
  /**
   * 处理落子事件
   */
  @UseGuards(WsJwtGuard)
  @SubscribeMessage('make_move')
  async handleMove(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { roomId: string; x: number; y: number },
  ) {
    const result = await this.gameService.makeMove(
      client.data.userId,
      data.roomId,
      data.x,
      data.y,
    );
    
    // 广播给房间内所有玩家
    this.server.to(data.roomId).emit('opponent_move', result);
    
    return result;
  }
}
```

### 3.6 DTO 开发规范

使用 `class-validator` 进行数据验证：

```typescript
import { IsString, IsOptional, IsInt, Min, Max, Length } from 'class-validator';
import { Type } from 'class-transformer';

/**
 * 创建房间DTO
 */
export class CreateRoomDto {
  @IsOptional()
  @IsString()
  @Length(4, 20, { message: '密码长度必须在4-20位之间' })
  password?: string;
}

/**
 * 落子DTO
 */
export class MakeMoveDto {
  @IsString()
  roomId: string;
  
  @IsInt({ message: 'X坐标必须是整数' })
  @Min(0, { message: 'X坐标不能小于0' })
  @Max(14, { message: 'X坐标不能大于14' })
  @Type(() => Number)
  x: number;
  
  @IsInt({ message: 'Y坐标必须是整数' })
  @Min(0, { message: 'Y坐标不能小于0' })
  @Max(14, { message: 'Y坐标不能大于14' })
  @Type(() => Number)
  y: number;
}

/**
 * 分页查询DTO
 */
export class PaginationDto {
  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;
  
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  @Type(() => Number)
  limit?: number = 20;
}
```

### 3.7 Entity 开发规范

```typescript
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { GameType, GameResult } from '@/common/constants/game.constants';

@Entity('game_records')
export class GameRecord {
  @PrimaryGeneratedColumn('increment', { type: 'bigint', unsigned: true })
  id: string;
  
  @Column({ type: 'varchar', length: 64, name: 'room_id' })
  roomId: string;
  
  @Column({ type: 'tinyint', name: 'game_type', comment: '游戏类型' })
  gameType: GameType;
  
  @Column({ type: 'bigint', unsigned: true, name: 'black_player_id', nullable: true })
  blackPlayerId: string;
  
  @Column({ type: 'bigint', unsigned: true, name: 'white_player_id', nullable: true })
  whitePlayerId: string;
  
  @Column({ type: 'bigint', unsigned: true, name: 'winner_id', nullable: true })
  winnerId: string;
  
  @Column({ type: 'tinyint', name: 'game_result' })
  gameResult: GameResult;
  
  @Column({ type: 'int', default: 0, name: 'total_steps' })
  totalSteps: number;
  
  @Column({ type: 'int', default: 0, comment: '对局时长(秒)' })
  duration: number;
  
  @Column({ type: 'text', name: 'game_data', nullable: true })
  gameData: string;
  
  @Column({ type: 'tinyint', name: 'ai_difficulty', nullable: true })
  aiDifficulty: number;
  
  @Column({ type: 'datetime', name: 'started_at' })
  startedAt: Date;
  
  @Column({ type: 'datetime', name: 'ended_at' })
  endedAt: Date;
  
  @CreateDateColumn({ type: 'datetime', name: 'created_at' })
  createdAt: Date;
  
  @Index()
  @Column({ type: 'bigint', unsigned: true, name: 'black_player_id' })
  blackPlayerIdIndex: string;
}
```

---

## 四、代码规范

### 4.1 命名规范

#### 4.1.1 文件命名

- **模块文件：** `xxx.module.ts`
- **控制器文件：** `xxx.controller.ts`
- **服务文件：** `xxx.service.ts`
- **网关文件：** `xxx.gateway.ts`
- **实体文件：** `xxx.entity.ts`
- **DTO文件：** `xxx.dto.ts`
- **常量文件：** `xxx.constants.ts`
- **工具文件：** `xxx.util.ts`

#### 4.1.2 变量命名

```typescript
// ✅ 正确的命名
const userName = 'John';           // 驼峰命名
const MAX_RETRY_COUNT = 3;        // 常量大写
const gameService: GameService;    // 类型注解

// ❌ 错误的命名
const user_name = 'John';          // 不要使用下划线
const maxretrycount = 3;           // 常量要大写
const gs: GameService;             // 避免缩写
```

#### 4.1.3 函数命名

```typescript
// ✅ 动词开头，语义清晰
async createGame() {}
async findGameById(id: string) {}
async updateUserScore(userId: string, score: number) {}
async deleteExpiredRooms() {}
async isGameFinished(gameId: string): Promise<boolean> {}
async hasPermission(userId: string): Promise<boolean> {}

// ❌ 避免
async game() {}              // 不清晰
async data() {}              // 太泛化
async process() {}           // 不明确
```

#### 4.1.4 类命名

```typescript
// ✅ 使用PascalCase，名词
class GameService {}
class UserController {}
class GameRecord {}
class CreateRoomDto {}

// ❌ 避免
class gameService {}         // 首字母要大写
class Game_Service {}        // 不要使用下划线
```

### 4.2 注释规范

#### 4.2.1 文件头注释

```typescript
/**
 * 游戏服务
 * 
 * @description 处理游戏核心逻辑，包括落子、胜负判断、AI对战等
 * @author 张三
 * @date 2025-10-15
 */
```

#### 4.2.2 函数注释

```typescript
/**
 * 创建游戏房间
 * 
 * @param userId 创建者用户ID
 * @param password 房间密码（可选）
 * @returns 房间信息
 * @throws RoomFullException 房间已满
 * @throws UnauthorizedException 未授权
 */
async createRoom(userId: string, password?: string): Promise<Room> {
  // 实现...
}
```

#### 4.2.3 复杂逻辑注释

```typescript
/**
 * 计算ELO评分变化
 * 使用标准ELO算法: 新评分 = 旧评分 + K * (实际得分 - 期望得分)
 */
calculateRatingChange(playerRating: number, opponentRating: number, won: boolean): number {
  // 计算期望得分
  const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - playerRating) / 400));
  
  // 实际得分：赢=1，输=0
  const actualScore = won ? 1 : 0;
  
  // 计算评分变化
  const ratingChange = GAME_CONFIG.RATING_K_FACTOR * (actualScore - expectedScore);
  
  return Math.round(ratingChange);
}
```

### 4.3 代码格式规范

#### 4.3.1 缩进和空格

- 使用 2 个空格缩进
- 操作符两边加空格
- 逗号后加空格

```typescript
// ✅ 正确
const result = a + b;
const arr = [1, 2, 3];
function test(a: number, b: number) {}

// ❌ 错误
const result=a+b;
const arr=[1,2,3];
function test(a:number,b:number){}
```

#### 4.3.2 代码行长度

- 单行代码不超过 100 个字符
- 超长代码要换行

```typescript
// ✅ 正确
const game = await this.gameRecordRepository.findOne({
  where: { id: gameId },
  relations: ['blackPlayer', 'whitePlayer'],
});

// ❌ 避免
const game = await this.gameRecordRepository.findOne({ where: { id: gameId }, relations: ['blackPlayer', 'whitePlayer'] });
```

#### 4.3.3 导入顺序

```typescript
// 1. Node.js 内置模块
import * as path from 'path';

// 2. 第三方模块
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';

// 3. 项目内部模块（按字母顺序）
import { GameService } from '@/modules/game/game.service';
import { UserService } from '@/modules/user/user.service';
import { GAME_CONFIG } from '@/common/constants/game.constants';
```

### 4.4 错误处理规范

```typescript
import { HttpException, HttpStatus } from '@nestjs/common';
import { ERROR_CODES, ERROR_MESSAGES } from '@/common/constants/error-codes.constants';

// ✅ 使用自定义错误码
async findGame(gameId: string) {
  const game = await this.gameRecordRepository.findOne({ where: { id: gameId } });
  
  if (!game) {
    throw new HttpException(
      {
        code: ERROR_CODES.GAME_NOT_FOUND,
        message: ERROR_MESSAGES[ERROR_CODES.GAME_NOT_FOUND],
      },
      HttpStatus.NOT_FOUND,
    );
  }
  
  return game;
}

// ✅ 统一的异常过滤器
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    
    const status = exception.getStatus?.() || HttpStatus.INTERNAL_SERVER_ERROR;
    const exceptionResponse = exception.getResponse?.();
    
    response.status(status).json({
      code: exceptionResponse?.code || ERROR_CODES.UNKNOWN_ERROR,
      message: exceptionResponse?.message || ERROR_MESSAGES[ERROR_CODES.UNKNOWN_ERROR],
      timestamp: new Date().toISOString(),
    });
  }
}
```

---

## 五、数据库开发规范

### 5.1 查询优化

```typescript
// ✅ 使用索引字段查询
const user = await this.userRepository.findOne({
  where: { openid: 'xxx' }, // openid 有索引
});

// ✅ 只查询需要的字段
const users = await this.userRepository.find({
  select: ['id', 'nickname', 'avatar_url'],
  where: { level: 5 },
});

// ✅ 使用分页
const [records, total] = await this.gameRecordRepository.findAndCount({
  skip: (page - 1) * limit,
  take: limit,
  order: { created_at: 'DESC' },
});

// ❌ 避免查询全表
const allUsers = await this.userRepository.find(); // 危险！
```

### 5.2 事务处理

```typescript
import { DataSource } from 'typeorm';

@Injectable()
export class GameService {
  constructor(private dataSource: DataSource) {}
  
  /**
   * 游戏结束，更新双方战绩（使用事务）
   */
  async finishGame(gameId: string, winnerId: string) {
    const queryRunner = this.dataSource.createQueryRunner();
    
    await queryRunner.connect();
    await queryRunner.startTransaction();
    
    try {
      // 更新游戏记录
      await queryRunner.manager.update(GameRecord, gameId, {
        winnerId,
        endedAt: new Date(),
      });
      
      // 更新胜者战绩
      await queryRunner.manager.increment(
        User,
        { id: winnerId },
        'win_games',
        1,
      );
      
      // 更新败者战绩
      await queryRunner.manager.increment(
        User,
        { id: loserId },
        'lose_games',
        1,
      );
      
      await queryRunner.commitTransaction();
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }
}
```

---

## 六、Redis 使用规范

### 6.1 Key 命名规范

```typescript
/**
 * Redis Key 命名规范
 * 格式：模块:功能:参数
 */
export const REDIS_KEYS = {
  // 在线用户
  ONLINE_USERS: 'online:users',
  
  // 匹配队列
  MATCH_QUEUE: 'match:queue',
  
  // 房间信息
  ROOM_INFO: (roomId: string) => `room:${roomId}:info`,
  
  // 用户Socket映射
  USER_SOCKET: (userId: string) => `user:${userId}:socket`,
  
  // 排行榜缓存
  LEADERBOARD: (type: string, period: string) => `leaderboard:${type}:${period}`,
} as const;
```

### 6.2 使用示例

```typescript
import { Injectable } from '@nestjs/common';
import { RedisService } from '@/shared/redis/redis.service';
import { REDIS_KEYS } from '@/common/constants/redis-keys.constants';

@Injectable()
export class MatchService {
  constructor(private redisService: RedisService) {}
  
  /**
   * 添加到匹配队列
   */
  async addToMatchQueue(userId: string): Promise<void> {
    const timestamp = Date.now();
    await this.redisService.zadd(
      REDIS_KEYS.MATCH_QUEUE,
      timestamp,
      userId,
    );
  }
  
  /**
   * 获取房间信息
   */
  async getRoomInfo(roomId: string): Promise<any> {
    const key = REDIS_KEYS.ROOM_INFO(roomId);
    const data = await this.redisService.hgetall(key);
    return data;
  }
}
```

---

## 七、Git 使用规范

### 7.1 分支管理

```
main         - 主分支（生产环境）
├── develop  - 开发分支
    ├── feature/xxx  - 功能分支
    ├── bugfix/xxx   - Bug修复分支
    └── hotfix/xxx   - 紧急修复分支
```

### 7.2 Commit 规范

使用语义化提交信息：

```bash
# 格式
<type>(<scope>): <subject>

# 类型（type）
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式（不影响代码运行）
refactor: 重构
perf:     性能优化
test:     测试
chore:    构建/工具变动

# 示例
feat(game): 实现五子棋AI算法
fix(match): 修复匹配超时问题
docs(api): 更新API文档
refactor(user): 优化用户服务代码结构
```

### 7.3 代码提交流程

```bash
# 1. 拉取最新代码
git pull origin develop

# 2. 创建功能分支
git checkout -b feature/game-ai

# 3. 开发并提交
git add .
git commit -m "feat(game): 实现Minimax算法"

# 4. 推送到远程
git push origin feature/game-ai

# 5. 创建Pull Request
# 在GitLab/GitHub上创建PR，等待代码审查
```

---

## 八、测试规范

### 8.1 单元测试

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { GameService } from './game.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { GameRecord } from './entities/game-record.entity';

describe('GameService', () => {
  let service: GameService;
  let mockRepository: any;
  
  beforeEach(async () => {
    mockRepository = {
      findOne: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
    };
    
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        GameService,
        {
          provide: getRepositoryToken(GameRecord),
          useValue: mockRepository,
        },
      ],
    }).compile();
    
    service = module.get<GameService>(GameService);
  });
  
  it('should be defined', () => {
    expect(service).toBeDefined();
  });
  
  describe('checkWin', () => {
    it('应该正确识别横向五连', () => {
      const board = Array(15).fill(null).map(() => Array(15).fill(0));
      // 模拟横向五连
      for (let i = 0; i < 5; i++) {
        board[7][i] = 1;
      }
      
      const result = service.checkWin(board, 7, 4, 1);
      expect(result).toBe(true);
    });
  });
});
```

---

## 九、性能优化规范

### 9.1 避免N+1查询

```typescript
// ❌ N+1查询问题
async getGamesWithPlayers(gameIds: string[]) {
  const games = await this.gameRecordRepository.findByIds(gameIds);
  
  for (const game of games) {
    game.blackPlayer = await this.userRepository.findOne(game.blackPlayerId); // N次查询
    game.whitePlayer = await this.userRepository.findOne(game.whitePlayerId); // N次查询
  }
  
  return games;
}

// ✅ 使用关联查询
async getGamesWithPlayers(gameIds: string[]) {
  return this.gameRecordRepository.find({
    where: { id: In(gameIds) },
    relations: ['blackPlayer', 'whitePlayer'], // 一次查询
  });
}
```

### 9.2 使用缓存

```typescript
/**
 * 获取排行榜（带缓存）
 */
async getLeaderboard(type: string, period: string) {
  const cacheKey = REDIS_KEYS.LEADERBOARD(type, period);
  
  // 先从缓存获取
  const cached = await this.redisService.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // 缓存未命中，查询数据库
  const data = await this.leaderboardRepository.find({
    where: { rank_type: type, period },
    order: { rank: 'ASC' },
    take: 100,
  });
  
  // 写入缓存
  await this.redisService.setex(
    cacheKey,
    RANK_CONFIG.CACHE_TTL,
    JSON.stringify(data),
  );
  
  return data;
}
```

---

## 十、安全规范

### 10.1 输入验证

```typescript
// ✅ 使用DTO + class-validator 验证所有输入
@Post('move')
async makeMove(@Body() dto: MakeMoveDto) {
  // DTO已自动验证，安全
  return this.gameService.makeMove(dto);
}
```

### 10.2 SQL注入防护

```typescript
// ✅ 使用参数化查询
const users = await this.userRepository
  .createQueryBuilder('user')
  .where('user.nickname = :nickname', { nickname })
  .getMany();

// ❌ 避免字符串拼接
const users = await this.userRepository.query(
  `SELECT * FROM users WHERE nickname = '${nickname}'`, // 危险！
);
```

### 10.3 敏感信息处理

```typescript
// ✅ 排除敏感字段
@Entity('users')
export class User {
  @Column({ select: false })  // 默认查询时不返回
  password: string;
  
  @Column({ select: false })
  openid: string;
}

// 手动排除
const user = await this.userRepository.findOne({ where: { id } });
delete user.openid;
return user;
```

---

## 十一、开发检查清单

### 11.1 代码提交前检查

- [ ] 已阅读相关的产品需求文档
- [ ] 代码中没有硬编码，所有常量都在 constants 中定义
- [ ] 所有配置都使用环境变量或配置文件
- [ ] 代码符合命名规范
- [ ] 添加了必要的注释
- [ ] 没有console.log等调试代码
- [ ] 通过了ESLint检查
- [ ] 编写了单元测试
- [ ] 测试通过
- [ ] 代码已格式化（Prettier）
- [ ] Git commit 信息符合规范

### 11.2 功能开发完成检查

- [ ] 功能符合产品需求文档
- [ ] API接口符合技术开发文档设计
- [ ] 数据库操作已优化（索引、查询）
- [ ] 添加了错误处理
- [ ] 添加了日志记录
- [ ] 进行了手动测试
- [ ] 更新了相关文档
- [ ] 通过了Code Review

---

## 十二、常见问题FAQ

### Q1: 什么时候应该定义新的常量？

**A:** 当你发现代码中出现以下情况时：
- 数字/字符串被多次使用
- 数字/字符串有特定业务含义
- 可能需要后续调整的值

### Q2: 常量应该放在哪里？

**A:** 
- 全局业务常量：`src/common/constants/`
- 模块内部常量：模块目录下的 `constants/` 文件夹

### Q3: 如何避免循环依赖？

**A:**
- 合理划分模块职责
- 使用 `forwardRef()` 解决必要的循环依赖
- 将共享逻辑抽取到独立的 shared 模块

### Q4: 数据库字段变更如何处理？

**A:**
- 编写migration文件
- 更新Entity定义
- 更新相关文档
- 通知团队成员

---

## 十三、开发工具推荐

### 13.1 VS Code 插件

- **ESLint** - 代码检查
- **Prettier** - 代码格式化
- **GitLens** - Git增强
- **Thunder Client** - API测试
- **Todo Tree** - TODO管理
- **Error Lens** - 错误提示增强

### 13.2 配置文件

**`.prettierrc`**
```json
{
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 100,
  "tabWidth": 2,
  "semi": true,
  "arrowParens": "always"
}
```

**`.eslintrc.js`**
```javascript
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};
```

---

## 十四、总结

本开发规范文档的核心原则：

1. **📖 文档先行** - 开发前必读docs文件夹所有文档
2. **🚫 禁止硬编码** - 所有常量、配置必须外部化
3. **📦 模块化开发** - 遵循NestJS最佳实践
4. **✅ 代码规范** - 统一的命名、注释、格式
5. **🔒 安全第一** - 输入验证、SQL注入防护
6. **⚡ 性能优化** - 避免N+1、使用缓存
7. **🧪 测试覆盖** - 编写单元测试
8. **📝 清晰注释** - 复杂逻辑必须注释

**请每位开发人员严格遵守本规范，确保代码质量和项目可维护性！**

---

**文档版本：** V1.0  
**创建日期：** 2025-10-15  
**最后更新：** 2025-10-15  
**维护人员：** 技术团队  

**重要提醒：** 
> 本文档会持续更新，请定期查阅。如有疑问或建议，请及时与技术负责人沟通。

